<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>GerÃ§ekÃ§i Su Birikme SimÃ¼lasyonu</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 1px solid #333;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.2);
            cursor: crosshair;
        }
        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            max-width: 300px;
        }
        h3 { margin: 0 0 10px 0; color: #00a8ff; }
        p { font-size: 0.9rem; color: #ccc; margin: 5px 0; }
    </style>
</head>
<body>

<div class="ui">
    <h3>Su FiziÄŸi Motoru</h3>
    <p>ğŸ–±ï¸ <b>Sol TÄ±k + SÃ¼rÃ¼kle:</b> Su ekle</p>
    <p>Su tanecikleri birikir, taÅŸar ve Ã§ukurlarÄ± doldurur.</p>
</div>

<canvas id="sandCanvas"></canvas>

<script>
    const canvas = document.getElementById('sandCanvas');
    const ctx = canvas.getContext('2d');

    // AYARLAR
    const w = 5; // Her bir su karesinin boyutu (Piksel)
    let cols, rows;
    let grid; // Mevcut durum
    let velocityGrid; // Suyun hÄ±zÄ±nÄ± (gerÃ§ekÃ§ilik iÃ§in) tutabiliriz ama ÅŸimdilik basit tutalÄ±m.
    let hueValue = 200; // Suyun rengi (Mavi tonlarÄ±)

    function setup() {
        // Canvas'Ä± tam ekran yapma ama performans iÃ§in Ä±zgara boyutunu yÃ¶netilebilir tutma
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        cols = Math.floor(canvas.width / w);
        rows = Math.floor(canvas.height / w);
        
        // IzgarayÄ± (Grid) oluÅŸtur ve iÃ§ini 0 (boÅŸ) ile doldur
        grid = make2DArray(cols, rows);
    }

    function make2DArray(cols, rows) {
        let arr = new Array(cols);
        for (let i = 0; i < arr.length; i++) {
            arr[i] = new Array(rows).fill(0);
        }
        return arr;
    }

    // FARE ETKÄ°LEÅÄ°MÄ°
    let isMouseDown = false;

    document.addEventListener('mousedown', () => isMouseDown = true);
    document.addEventListener('mouseup', () => isMouseDown = false);
    
    // Mobilde dokunmatik desteÄŸi iÃ§in
    document.addEventListener('touchstart', () => isMouseDown = true);
    document.addEventListener('touchend', () => isMouseDown = false);

    // Mouse konumu
    let mouseX = 0;
    let mouseY = 0;
    canvas.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });
    canvas.addEventListener('touchmove', (e) => {
        mouseX = e.touches[0].clientX;
        mouseY = e.touches[0].clientY;
    });

    function draw() {
        // ArkaplanÄ± temizle
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Yeni bir Ä±zgara oluÅŸtur (Bir sonraki kare iÃ§in hesaplama)
        let nextGrid = make2DArray(cols, rows);

        // Fare basÄ±lÄ±ysa su ekle
        if (isMouseDown) {
            let mouseCol = Math.floor(mouseX / w);
            let mouseRow = Math.floor(mouseY / w);
            
            // FÄ±rÃ§a boyutu (Matrix brush)
            let extent = 4; // FÄ±rÃ§a kalÄ±nlÄ±ÄŸÄ±
            for (let i = -extent; i <= extent; i++) {
                for (let j = -extent; j <= extent; j++) {
                    let col = mouseCol + i;
                    let row = mouseRow + j;
                    // Ekran sÄ±nÄ±rlarÄ± iÃ§inde mi ve rastgelelik ekle (doÄŸal akÄ±ÅŸ iÃ§in)
                    if (col >= 0 && col < cols && row >= 0 && row < rows) {
                        if (Math.random() > 0.1) { 
                            grid[col][row] = hueValue; 
                        }
                    }
                }
            }
            // Rengi zamanla deÄŸiÅŸtir (GÃ¶kkuÅŸaÄŸÄ± suyu efekti iÃ§in)
            hueValue += 0.5; 
            if(hueValue > 255) hueValue = 180; // Sadece mavi-mor aralÄ±ÄŸÄ±nda kalsÄ±n
        }

        // --- FÄ°ZÄ°K HESAPLAMALARI ---
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                let state = grid[i][j];
                
                // EÄŸer bu hÃ¼crede su varsa (0 deÄŸilse)
                if (state > 0) {
                    let below = j + 1;
                    let left = i - 1;
                    let right = i + 1;

                    // 1. KURAL: AÅŸaÄŸÄ±sÄ± boÅŸ mu?
                    if (below < rows && grid[i][below] === 0) {
                        nextGrid[i][below] = state; // AÅŸaÄŸÄ± dÃ¼ÅŸ
                    } 
                    // 2. KURAL: AÅŸaÄŸÄ±sÄ± doluysa, sol-alt veya saÄŸ-alt boÅŸ mu? (AkÄ±ÅŸkanlÄ±k)
                    else if (below < rows && left >= 0 && grid[left][below] === 0) {
                         nextGrid[left][below] = state; // Sola kayarak dÃ¼ÅŸ
                    } else if (below < rows && right < cols && grid[right][below] === 0) {
                         nextGrid[right][below] = state; // SaÄŸa kayarak dÃ¼ÅŸ
                    }
                    // 3. KURAL (YAYILMA): AÅŸaÄŸÄ± tamamen doluysa yanlara git (Suyu kumdan ayÄ±ran Ã¶zellik)
                    else if (left >= 0 && grid[left][j] === 0) {
                         nextGrid[left][j] = state; // Sola yayÄ±l
                    } else if (right < cols && grid[right][j] === 0) {
                         nextGrid[right][j] = state; // SaÄŸa yayÄ±l
                    }
                    // HiÃ§bir yere gidemiyorsa olduÄŸu yerde kal
                    else {
                        nextGrid[i][j] = state;
                    }
                    
                    // Ekrana Ã§iz
                    ctx.fillStyle = `hsl(${state}, 100%, 50%)`;
                    ctx.fillRect(i * w, j * w, w, w);
                }
            }
        }

        grid = nextGrid;
        requestAnimationFrame(draw);
    }

    setup();
    draw();

    // Ekran boyutu deÄŸiÅŸirse resetle
    window.addEventListener('resize', setup);

</script>

</body>
</html>
